<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris 1-bit</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");
      :root {
        --bg: #000000;
        --fg: #ffffff;
        --grid: #4e4c4c;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: var(--bg);
        color: var(--fg);
        font-family: "Press Start 2P", monospace;
      }
      body {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .container {
        display: flex;
        gap: 24px;
        align-items: flex-start;
      }
      .panel {
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-width: 200px;
      }
      .panel h1 {
        margin: 0;
        font-size: 16px;
        letter-spacing: 1px;
      }
      .stats {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        font-size: 12px;
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .control-btn {
        width: 48px;
        height: 40px;
        background: var(--bg);
        color: var(--fg);
        border: 2px solid var(--fg);
        font-family: "Press Start 2P", monospace;
        font-size: 16px;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        padding: 0;
      }
      .control-btn:active {
        transform: translateY(1px);
      }
      .stat {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .stat .label {
        color: var(--grid);
        font-size: 10px;
      }
      .stat .value {
        font-size: 14px;
      }
      .canvas-wrap {
        position: relative;
        width: 400px;
        height: 800px;
      }
      canvas {
        width: 400px;
        height: 800px;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        display: block;
        background: var(--bg);
        border: 2px solid var(--fg);
      }
      .scanlines {
        position: absolute;
        inset: 0;
        pointer-events: none;
        background: repeating-linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0.8) 0px,
          rgba(0, 0, 0, 0.8) 2px,
          rgba(0, 0, 0, 0.3) 3px,
          rgba(0, 0, 0, 0.3) 4px
        );
        mix-blend-mode: multiply;
      }
      .hint {
        font-size: 10px;
        line-height: 1.6;
        color: var(--grid);
        max-width: 220px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="canvas-wrap">
        <canvas id="game" width="200" height="400"></canvas>
        <div class="scanlines"></div>
      </div>
      <div class="panel">
        <h1>TETRIS</h1>
        <div class="stats">
          <div class="stat">
            <div class="label">SCORE</div>
            <div class="value" id="score">0</div>
          </div>
          <div class="stat">
            <div class="label">BEST</div>
            <div class="value" id="best">0</div>
          </div>
          <div class="stat">
            <div class="label">LEVEL</div>
            <div class="value" id="level">0</div>
          </div>
          <div class="stat">
            <div class="label">LINES</div>
            <div class="value" id="lines">0</div>
          </div>
        </div>
        <div class="controls">
          <button class="control-btn" id="playPause" type="button" tabindex="-1">
            ▶
          </button>
          <button class="control-btn" id="restart" type="button" tabindex="-1">
            ↻
          </button>
        </div>
        <div class="hint">
          ↑ 旋转<br />
          ← → 移动<br />
          ↓ 软降<br />
          Space 硬降
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = false;

      const scoreEl = document.getElementById("score");
      const bestEl = document.getElementById("best");
      const levelEl = document.getElementById("level");
      const linesEl = document.getElementById("lines");
      const playPauseBtn = document.getElementById("playPause");
      const restartBtn = document.getElementById("restart");

      const COLS = 10;
      const ROWS = 20;
      const CELL = 20;
      const SUB = 4;
      const GAP = 1;
      const SUB_TOTAL = SUB * 4 + GAP * 3;

      const BASE_SPEED = 1000;
      const MIN_SPEED = 100;
      const BEST_KEY = "tetris_best";

      const SHAPES = {
        I: [
          [
            [0, 0, 0, 0],
            [1, 1, 1, 1],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 0, 1, 0],
            [0, 0, 1, 0],
            [0, 0, 1, 0],
            [0, 0, 1, 0]
          ],
          [
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [1, 1, 1, 1],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 1, 0, 0]
          ]
        ],
        O: [
          [
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 1, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ]
        ],
        T: [
          [
            [0, 1, 0, 0],
            [1, 1, 1, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 0, 0],
            [0, 1, 1, 0],
            [0, 1, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 0, 0, 0],
            [1, 1, 1, 0],
            [0, 1, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 0, 0],
            [1, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 0, 0]
          ]
        ],
        S: [
          [
            [0, 1, 1, 0],
            [1, 1, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 0, 0],
            [0, 1, 1, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 0, 0, 0],
            [0, 1, 1, 0],
            [1, 1, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [1, 0, 0, 0],
            [1, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 0, 0]
          ]
        ],
        Z: [
          [
            [1, 1, 0, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 0, 1, 0],
            [0, 1, 1, 0],
            [0, 1, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 0, 0, 0],
            [1, 1, 0, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 0, 0],
            [1, 1, 0, 0],
            [1, 0, 0, 0],
            [0, 0, 0, 0]
          ]
        ],
        J: [
          [
            [1, 0, 0, 0],
            [1, 1, 1, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 1, 0],
            [0, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 0, 0, 0],
            [1, 1, 1, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 0, 0],
            [0, 1, 0, 0],
            [1, 1, 0, 0],
            [0, 0, 0, 0]
          ]
        ],
        L: [
          [
            [0, 0, 1, 0],
            [1, 1, 1, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 1, 1, 0],
            [0, 0, 0, 0]
          ],
          [
            [0, 0, 0, 0],
            [1, 1, 1, 0],
            [1, 0, 0, 0],
            [0, 0, 0, 0]
          ],
          [
            [1, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 0, 0]
          ]
        ]
      };

      const TYPES = Object.keys(SHAPES);

      const state = {
        board: [],
        piece: null,
        score: 0,
        best: 0,
        lines: 0,
        level: 0,
        dropTimer: 0,
        dropInterval: BASE_SPEED,
        lastTime: 0,
        gameOver: false,
        softDrop: false,
        running: false,
        newRecord: false
      };

      function loadBest() {
        const stored = Number(localStorage.getItem(BEST_KEY));
        return Number.isFinite(stored) ? stored : 0;
      }

      function saveBest() {
        localStorage.setItem(BEST_KEY, state.best.toString());
      }

      function createBoard() {
        const board = [];
        for (let y = 0; y < ROWS; y += 1) {
          const row = new Array(COLS).fill(0);
          board.push(row);
        }
        return board;
      }

      function randomPiece() {
        const type = TYPES[Math.floor(Math.random() * TYPES.length)];
        return {
          type,
          rotation: 0,
          x: 3,
          y: 0
        };
      }

      function getMatrix(piece) {
        return SHAPES[piece.type][piece.rotation];
      }

      function resetGame() {
        state.board = createBoard();
        state.piece = randomPiece();
        state.score = 0;
        state.lines = 0;
        state.level = 0;
        state.dropTimer = 0;
        state.dropInterval = BASE_SPEED;
        state.lastTime = performance.now();
        state.gameOver = false;
        state.softDrop = false;
        state.running = false;
        state.newRecord = false;
        updateHud();
        updateControls();
      }

      function collide(board, piece) {
        const matrix = getMatrix(piece);
        for (let y = 0; y < 4; y += 1) {
          for (let x = 0; x < 4; x += 1) {
            if (!matrix[y][x]) continue;
            const boardX = piece.x + x;
            const boardY = piece.y + y;
            if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
              return true;
            }
            if (boardY >= 0 && board[boardY][boardX]) {
              return true;
            }
          }
        }
        return false;
      }

      function merge(board, piece) {
        const matrix = getMatrix(piece);
        for (let y = 0; y < 4; y += 1) {
          for (let x = 0; x < 4; x += 1) {
            if (!matrix[y][x]) continue;
            const boardY = piece.y + y;
            if (boardY >= 0) {
              board[boardY][piece.x + x] = 1;
            }
          }
        }
      }

      function clearLines() {
        let cleared = 0;
        for (let y = ROWS - 1; y >= 0; y -= 1) {
          if (state.board[y].every((cell) => cell === 1)) {
            state.board.splice(y, 1);
            state.board.unshift(new Array(COLS).fill(0));
            cleared += 1;
            y += 1;
          }
        }
        if (cleared > 0) {
          const lineScores = [0, 40, 100, 300, 1200];
          state.score += lineScores[cleared] * (state.level + 1);
          state.lines += cleared;
          state.level = Math.floor(state.lines / 10);
          const speed = BASE_SPEED * Math.pow(0.9, state.level);
          state.dropInterval = Math.max(MIN_SPEED, Math.round(speed));
          updateBest();
        }
      }

      function move(offsetX) {
        state.piece.x += offsetX;
        if (collide(state.board, state.piece)) {
          state.piece.x -= offsetX;
        }
      }

      function rotate() {
        const prev = state.piece.rotation;
        state.piece.rotation = (state.piece.rotation + 1) % 4;
        if (!collide(state.board, state.piece)) return;
        state.piece.x -= 1;
        if (!collide(state.board, state.piece)) return;
        state.piece.x += 2;
        if (!collide(state.board, state.piece)) return;
        state.piece.x -= 1;
        state.piece.rotation = prev;
      }

      function drop() {
        state.piece.y += 1;
        if (!collide(state.board, state.piece)) return;
        state.piece.y -= 1;
        merge(state.board, state.piece);
        clearLines();
        spawnPiece();
        updateHud();
      }

      function hardDrop() {
        while (!collide(state.board, state.piece)) {
          state.piece.y += 1;
        }
        state.piece.y -= 1;
        merge(state.board, state.piece);
        clearLines();
        spawnPiece();
        updateHud();
      }

      function spawnPiece() {
        state.piece = randomPiece();
        if (collide(state.board, state.piece)) {
          state.gameOver = true;
          state.running = false;
          updateControls();
        }
      }

      function updateHud() {
        scoreEl.textContent = state.score.toString();
        bestEl.textContent = state.best.toString();
        levelEl.textContent = state.level.toString();
        linesEl.textContent = state.lines.toString();
      }

      function updateBest() {
        if (state.score > state.best) {
          state.best = state.score;
          state.newRecord = true;
          saveBest();
          updateHud();
        }
      }

      function updateControls() {
        playPauseBtn.textContent = state.running ? "⏹" : "▶";
      }

      function startGame() {
        if (state.gameOver) {
          resetGame();
        }
        state.running = true;
        state.dropTimer = 0;
        state.lastTime = performance.now();
        updateControls();
      }

      function togglePause() {
        if (!state.running) {
          startGame();
        } else {
          state.running = false;
          updateControls();
        }
      }

      function restartGame() {
        resetGame();
      }

      function drawCell(x, y) {
        const baseX = x * CELL;
        const baseY = y * CELL;
        for (let row = 0; row < 4; row += 1) {
          for (let col = 0; col < 4; col += 1) {
            const px = baseX + col * (SUB + GAP);
            const py = baseY + row * (SUB + GAP);
            ctx.fillRect(px, py, SUB, SUB);
          }
        }
      }

      function drawGrid() {
        ctx.strokeStyle = "#333333";
        ctx.lineWidth = 1;
        for (let x = 0; x <= COLS; x += 1) {
          ctx.beginPath();
          ctx.moveTo(x * CELL + 0.5, 0);
          ctx.lineTo(x * CELL + 0.5, ROWS * CELL);
          ctx.stroke();
        }
        for (let y = 0; y <= ROWS; y += 1) {
          ctx.beginPath();
          ctx.moveTo(0, y * CELL + 0.5);
          ctx.lineTo(COLS * CELL, y * CELL + 0.5);
          ctx.stroke();
        }
      }

      function drawBoard() {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        ctx.fillStyle = "#ffffff";
        for (let y = 0; y < ROWS; y += 1) {
          for (let x = 0; x < COLS; x += 1) {
            if (state.board[y][x]) {
              drawCell(x, y);
            }
          }
        }
      }

      function drawPiece() {
        const matrix = getMatrix(state.piece);
        ctx.fillStyle = "#ffffff";
        for (let y = 0; y < 4; y += 1) {
          for (let x = 0; x < 4; x += 1) {
            if (matrix[y][x]) {
              const drawX = state.piece.x + x;
              const drawY = state.piece.y + y;
              if (drawY >= 0) {
                drawCell(drawX, drawY);
              }
            }
          }
        }
      }

      function drawGameOver() {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "16px 'Press Start 2P', monospace";
        if (state.newRecord) {
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          ctx.fillText("NEW RECORD：", centerX, centerY - 12);
          ctx.fillText(`${state.best}`, centerX, centerY + 12);
        } else {
          ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
        }
      }

      function update(time) {
        const delta = time - state.lastTime;
        state.lastTime = time;
        if (!state.gameOver) {
          if (state.running) {
            state.dropTimer += delta;
            const interval = state.softDrop ? 50 : state.dropInterval;
            if (state.dropTimer >= interval) {
              drop();
              state.dropTimer = 0;
            }
          }
          drawBoard();
          drawPiece();
        } else {
          drawGameOver();
        }
        requestAnimationFrame(update);
      }

      document.addEventListener("keydown", (event) => {
        if (state.gameOver || !state.running) return;
        if (event.code === "ArrowLeft") {
          move(-1);
        } else if (event.code === "ArrowRight") {
          move(1);
        } else if (event.code === "ArrowUp") {
          rotate();
        } else if (event.code === "ArrowDown") {
          state.softDrop = true;
        } else if (event.code === "Space") {
          hardDrop();
        }
      });

      document.addEventListener("keyup", (event) => {
        if (event.code === "ArrowDown") {
          state.softDrop = false;
        }
      });

      playPauseBtn.addEventListener("click", () => {
        togglePause();
        playPauseBtn.blur();
      });

      restartBtn.addEventListener("click", () => {
        restartGame();
        restartBtn.blur();
      });

      playPauseBtn.addEventListener("keydown", (event) => {
        if (event.code === "Space" || event.code === "Enter") {
          event.preventDefault();
          event.stopPropagation();
        }
      });

      restartBtn.addEventListener("keydown", (event) => {
        if (event.code === "Space" || event.code === "Enter") {
          event.preventDefault();
          event.stopPropagation();
        }
      });

      state.best = loadBest();
      resetGame();
      requestAnimationFrame(update);
    </script>
  </body>
</html>
